/*
 * Считывание с возможностью повторного прикладывания через определенное время.
 * 
 * В программе выводятся различные сообщения для проверки правильности ее работы.
 * В частности, контролируется количество данных в буфере последовательного порта,
 * по которому считыватель присылает данные.
 */

/* UID
 * 0 символ - знак начала передачи (числовой код 2) 
 * 1-2 символы - служебные
 * 3-10 символы - собственно UID
 * 11-12 символы - проверочные
 * 13 символ - знак конца передачи (числовой код 3)
 */

// Определение длины uid, а также того,
// с какого по какой символ его выводить на экран
#define UID_LEN 14
#define UID_FROM 3
#define UID_TO 10

// Время до следующего считывания метки, мс
#define DELAY_FOR_ALL 2000

// Для хранения uid карт
char uid[14];


void setup() {
  // Запуск последовательных портов (Serial для вывода информации о работе программы,
  // по Serial1 производится обмен данным со считывателем)
  Serial.begin(9600);
  Serial1.begin(9600);
  while (!Serial || !Serial1) {
    delay(10);
  }
  while (Serial1.available()) {
    Serial1.read();
  }
}

void loop() {  
  // Вывод сообщения о начале очередного цикла
  Serial.println("loop");
  
  // Вывод количества доступных для считывания байт в буфере последовательного порта
  // Должно быть = 0
  Serial.println(Serial1.available());
  
  // Вывод сообщения о нахождении в режиме считывания
  Serial.println("waiting for rfid");
  
  // Ожидание метки
  while (Serial1.available() < UID_LEN) delay(10);

  // Вывод информации о считанной метке
  Serial.print("rfid found, uid = ");
  for (int i = 0; i < UID_LEN; ++i) {
    uid[i] = Serial1.read();
  }
  for (int i = UID_FROM; i <= UID_TO; ++i) {
    Serial.print(uid[i]);
  }
  Serial.println();
  
  // Сообщение о начале перерыва между считываниями
  Serial.println("not waiting for rfid");
  
  // Собственно перерыв
  delay(DELAY_FOR_ALL);
  
  // Вывод сообщения о конце перерыва между считываниями
  Serial.println("end of delay");
  
  // Вывод количества доступных для считывания байт в буфере последовательного порта
  // Может быть любым в диапазоне от 0 до 64 
  //(64 байта - максимальный размер буфера последовательного порта)
  Serial.println(Serial1.available());
  
  // Очистка буфера последовательного порта
  while (Serial1.available()) {
    Serial1.read();
  }
  
  // Вывод количества доступных для считывания байт в буфере последовательного порта
  // Должно быть = 0
  Serial.println(Serial1.available());
}
